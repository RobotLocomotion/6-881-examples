import numpy as np
import sys
from pydrake.systems.framework import BasicVector, LeafSystem, PortDataType
from plan_runner.robot_plans import *
from plan_runner.open_left_door_plans import *


class ManipStationPlanRunner(LeafSystem):
    """ A drake system that sends commands to the robot and gripper by evaluating the currently
    active Plan.

    The plan runner is constructed with a list of Plans (kuka_plans) and a list of gripper
    setpoints (gripper_setpoint_list).

    In its constructor, it adds two additional plans to kuka_plans for safety reasons:
    - The first plan holds the robot's current position for 3 seconds.
    - The second plan moves the robot from its current position, to the position at the beginning of
        the first plan in the Plans list.

    Plans in the modified kuka_plans are then activated in sequence.
    Each plan is active for plan.duration seconds.

    By default, the plan runner sends position and torque commands to iiwa at 200Hz,
    and gripper setpoint commands to the schunk WSG50 at a lower rate.
    At every update event, the commands are generated by evaluating the currently active plan.

    The current implementation requires either
    - kuka_plans be an empty list, or
    - kuka_plans[0].traj be a valid PiecewisePolynomial.
    """
    def __init__(self,
                 kuka_plans,
                 gripper_setpoint_list,
                 control_period=0.005,
                 print_period=0.5):
        LeafSystem.__init__(self)
        assert len(kuka_plans) == len(gripper_setpoint_list)
        self.set_name("Manipulation Plan Runner")

        # Stuff for iiwa control
        self.nq = 7
        self.print_period = print_period
        self.last_print_time = -print_period
        self.control_period = control_period

        # Add a zero order hold to hold the current position of the robot
        kuka_plans.insert(0, JointSpacePlanRelative(
            duration=2.0, delta_q=np.zeros(self.nq)))
        gripper_setpoint_list.insert(0, 0.055)

        if (len(kuka_plans) > 1 and
                kuka_plans[1].type == PlanTypes["JointSpacePlan"]):
            # Insert to the beginning of plan_list a plan that moves the robot from its
            # current position to plan_list[0].traj.value(0)
            kuka_plans.insert(1, JointSpacePlanGoToTarget(
                duration=5.0, q_target=kuka_plans[1].traj.value(0).flatten()))
            gripper_setpoint_list.insert(0, 0.055)

        self.gripper_setpoint_list = gripper_setpoint_list
        self.kuka_plans_list = kuka_plans

        self.current_plan_start_time = 0.
        self.current_plan = None
        self.current_gripper_setpoint = None
        self.current_plan_idx = 0

        # iiwa position input port
        self.iiwa_position_input_port = \
            self.DeclareVectorInputPort(
                "iiwa_position", BasicVector(self.nq))

        # iiwa velocity input port
        self.iiwa_velocity_input_port = \
            self.DeclareVectorInputPort(
                "iiwa_velocity", BasicVector(self.nq))

        # iiwa external torque input port
        self.iiwa_external_torque_input_port = \
            self.DeclareVectorInputPort(
                "iiwa_torque_external", BasicVector(self.nq))

        # position and torque command output port
        self.iiwa_position_command_output_port = \
            self.DeclareVectorOutputPort(
                "iiwa_position_command",
                BasicVector(self.nq), self._CalcIiwaPositionCommand)
        self.iiwa_torque_command_output_port = \
            self.DeclareVectorOutputPort(
                "iiwa_torque_command",
                BasicVector(self.nq), self._CalcIiwaTorqueCommand)

        # gripper setpoint and torque limit
        self.hand_setpoint_output_port = \
            self.DeclareVectorOutputPort(
                "gripper_setpoint", BasicVector(1),
                self._CalcGripperSetpointOutput)
        self.gripper_force_limit_output_port = \
            self.DeclareVectorOutputPort(
                "force_limit", BasicVector(1), self._CalcForceLimitOutput)

        # Declare command publishing rate
        self.q_cmd_idx = self.DeclareDiscreteState(self.nq)
        self.tau_cmd_idx = self.DeclareDiscreteState(self.nq)
        self.wsg_cmd_idx = self.DeclareDiscreteState(1)
        self.DeclarePeriodicDiscreteUpdate(period_sec=self.control_period)

        self.kPlanDurationMultiplier = 1.1

        # logging joint angle references
        self.q_ref_log = []
        self.sample_times = []

    def _GetCurrentPlan(self, context):
        t = context.get_time()

        if self.current_plan is None:
            # This is true only after the constructor is called and at the first control tick after the
            # simulator starts.
            self.current_plan = self.kuka_plans_list.pop(0)
            self.current_gripper_setpoint = self.gripper_setpoint_list.pop(0)
            self.current_plan_start_time = 0.
        else:
            adjusted_duration = self.current_plan.duration * self.kPlanDurationMultiplier
            if t - self.current_plan_start_time >= adjusted_duration:
                if len(self.kuka_plans_list) > 0:
                    self.current_plan = self.kuka_plans_list.pop(0)
                    self.current_gripper_setpoint = self.gripper_setpoint_list.pop(0)
                else:
                    # There are no more available plans. Hold current position.
                    self.current_plan = JointSpacePlanRelative(
                        duration=3600., delta_q=np.zeros(self.nq))
                    print 'No more plans to run, holding current position...\n'

                self.current_plan_start_time = t
                self.current_plan_idx += 1
                print 'Running plan %d' % self.current_plan_idx + " (type: " + self.current_plan.type + \
                      "), starting at %f for a duration of %f seconds." % \
                      (t, self.current_plan.duration*self.kPlanDurationMultiplier) + "\n"

    def DoCalcDiscreteVariableUpdates(self, context, events, discrete_state):
        # Call base method to ensure we do not get recursion.
        LeafSystem.DoCalcDiscreteVariableUpdates(self, context, events, discrete_state)

        self._GetCurrentPlan(context)

        t = context.get_time()
        q_iiwa = self.iiwa_position_input_port.Eval(context)
        v_iiwa = self.iiwa_velocity_input_port.Eval(context)
        tau_iiwa = self.iiwa_external_torque_input_port.Eval(context)
        t_plan = t - self.current_plan_start_time

        q_cmd_new = discrete_state.get_mutable_vector(
            self.q_cmd_idx).get_mutable_value()
        tau_cmd_new = discrete_state.get_mutable_vector(
            self.tau_cmd_idx).get_mutable_value()
        wsg_cmd_new = discrete_state.get_mutable_vector(
            self.wsg_cmd_idx).get_mutable_value()

        # TODO(kmuhlrad): this line now errors
        q_cmd_new[:] = \
            self.current_plan.CalcPositionCommand(
                q_iiwa, v_iiwa, tau_iiwa, t_plan, self.control_period,
                q_ref_log=self.q_ref_log,
                sample_times=self.sample_times,
                t=t)
        tau_cmd_new[:] = \
            self.current_plan.CalcTorqueCommand(
                q_iiwa, v_iiwa, tau_iiwa, t_plan, self.control_period)
        wsg_cmd_new[:] = self.current_gripper_setpoint

        # print current simulation time
        if (self.print_period and
                t - self.last_print_time >= self.print_period):
            print "t: ", t
            self.last_print_time = t

    def _CalcIiwaPositionCommand(self, context, y_data):
        state = context.get_discrete_state(self.q_cmd_idx).get_value()
        y = y_data.get_mutable_value()
        y[:] = state

    def _CalcIiwaTorqueCommand(self, context, y_data):
        state = context.get_discrete_state(self.tau_cmd_idx).get_value()
        y = y_data.get_mutable_value()
        y[:] = state

    def _CalcGripperSetpointOutput(self, context, y_data):
        state = context.get_discrete_state(self.wsg_cmd_idx).get_value()
        y = y_data.get_mutable_value()
        y[:] = state

    def _CalcForceLimitOutput(self, context, output):
        output.SetAtIndex(0, 15.0)

